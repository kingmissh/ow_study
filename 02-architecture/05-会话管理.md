# 会话管理与持久化

## 概述

会话管理负责维护用户与 AI 的长期对话状态，包括历史记录、上下文、偏好设置等。

---

## 会话模型

### 会话结构

```typescript
interface Session {
  id: string;
  userId: string;
  createdAt: number;
  lastActiveAt: number;
  status: 'active' | 'idle' | 'closed';
  
  // 对话历史
  messages: Message[];
  
  // 当前上下文
  context: SessionContext;
  
  // 用户偏好
  preferences: UserPreferences;
  
  // Agent 状态
  agentState: AgentState;
  
  // 元数据
  metadata: Record<string, any>;
}

interface SessionContext {
  // 当前话题
  currentTopic?: string;
  
  // 待处理任务
  pendingTasks: Task[];
  
  // 临时变量
  variables: Map<string, any>;
  
  // 上下文窗口
  contextWindow: Message[];
}
```

---

## 持久化策略

### 存储层设计

```typescript
interface SessionStorage {
  // 保存会话
  save(session: Session): Promise<void>;
  
  // 加载会话
  load(sessionId: string): Promise<Session | null>;
  
  // 更新会话
  update(sessionId: string, updates: Partial<Session>): Promise<void>;
  
  // 删除会话
  delete(sessionId: string): Promise<void>;
  
  // 查询会话
  query(criteria: SessionQuery): Promise<Session[]>;
}
```

### 文件系统存储

```typescript
class FileSystemStorage implements SessionStorage {
  private basePath: string;
  
  async save(session: Session): Promise<void> {
    const filePath = this.getSessionPath(session.id);
    const data = JSON.stringify(session, null, 2);
    
    await fs.promises.writeFile(filePath, data, 'utf-8');
  }
  
  async load(sessionId: string): Promise<Session | null> {
    const filePath = this.getSessionPath(sessionId);
    
    try {
      const data = await fs.promises.readFile(filePath, 'utf-8');
      return JSON.parse(data);
    } catch (error) {
      if (error.code === 'ENOENT') {
        return null;
      }
      throw error;
    }
  }
  
  private getSessionPath(sessionId: string): string {
    return path.join(this.basePath, 'sessions', `${sessionId}.json`);
  }
}
```

### 数据库存储

```typescript
class DatabaseStorage implements SessionStorage {
  private db: Database;
  
  async save(session: Session): Promise<void> {
    await this.db.query(`
      INSERT INTO sessions (id, user_id, data, created_at, last_active_at)
      VALUES ($1, $2, $3, $4, $5)
      ON CONFLICT (id) DO UPDATE
      SET data = $3, last_active_at = $5
    `, [
      session.id,
      session.userId,
      JSON.stringify(session),
      session.createdAt,
      session.lastActiveAt
    ]);
  }
  
  async load(sessionId: string): Promise<Session | null> {
    const result = await this.db.query(`
      SELECT data FROM sessions WHERE id = $1
    `, [sessionId]);
    
    if (result.rows.length === 0) {
      return null;
    }
    
    return JSON.parse(result.rows[0].data);
  }
}
```

---

## 会话生命周期

### 会话创建

```typescript
class SessionFactory {
  create(userId: string): Session {
    return {
      id: this.generateSessionId(),
      userId,
      createdAt: Date.now(),
      lastActiveAt: Date.now(),
      status: 'active',
      messages: [],
      context: {
        pendingTasks: [],
        variables: new Map(),
        contextWindow: []
      },
      preferences: this.loadDefaultPreferences(),
      agentState: this.createInitialAgentState(),
      metadata: {}
    };
  }
  
  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
```

### 会话激活

```typescript
class SessionActivator {
  async activate(session: Session): Promise<void> {
    // 更新状态
    session.status = 'active';
    session.lastActiveAt = Date.now();
    
    // 恢复 Agent 状态
    await this.restoreAgentState(session);
    
    // 加载上下文
    await this.loadContext(session);
    
    // 触发激活事件
    this.emit('session:activated', session);
  }
  
  private async restoreAgentState(session: Session): Promise<void> {
    // 恢复工具状态
    await this.restoreTools(session.agentState);
    
    // 恢复记忆
    await this.restoreMemory(session.agentState);
    
    // 恢复配置
    await this.restoreConfig(session.agentState);
  }
}
```

### 会话休眠

```typescript
class SessionHibernator {
  async hibernate(session: Session): Promise<void> {
    // 更新状态
    session.status = 'idle';
    
    // 保存当前状态
    await this.saveState(session);
    
    // 清理内存
    await this.cleanupMemory(session);
    
    // 触发休眠事件
    this.emit('session:hibernated', session);
  }
  
  private async cleanupMemory(session: Session): Promise<void> {
    // 压缩历史消息
    session.messages = this.compressMessages(session.messages);
    
    // 清理临时变量
    session.context.variables.clear();
    
    // 保留最近的上下文窗口
    session.context.contextWindow = session.context.contextWindow.slice(-10);
  }
}
```

### 会话关闭

```typescript
class SessionCloser {
  async close(session: Session): Promise<void> {
    // 更新状态
    session.status = 'closed';
    
    // 完成待处理任务
    await this.completePendingTasks(session);
    
    // 保存最终状态
    await this.saveFinalState(session);
    
    // 清理资源
    await this.cleanup(session);
    
    // 触发关闭事件
    this.emit('session:closed', session);
  }
  
  private async completePendingTasks(session: Session): Promise<void> {
    for (const task of session.context.pendingTasks) {
      try {
        await this.completeTask(task);
      } catch (error) {
        logger.error('Failed to complete task', { task, error });
      }
    }
  }
}
```

---

## 消息历史管理

### 历史记录存储

```typescript
class MessageHistory {
  private messages: Message[] = [];
  private maxSize: number = 1000;
  
  add(message: Message): void {
    this.messages.push(message);
    
    // 限制大小
    if (this.messages.length > this.maxSize) {
      this.messages = this.messages.slice(-this.maxSize);
    }
  }
  
  get(limit: number = 20): Message[] {
    return this.messages.slice(-limit);
  }
  
  search(query: string): Message[] {
    return this.messages.filter(msg =>
      msg.content.toLowerCase().includes(query.toLowerCase())
    );
  }
  
  clear(): void {
    this.messages = [];
  }
}
```

### 历史压缩

```typescript
class HistoryCompressor {
  async compress(messages: Message[]): Promise<Message[]> {
    if (messages.length <= 50) {
      return messages;
    }
    
    // 保留最近的消息
    const recent = messages.slice(-20);
    
    // 压缩旧消息
    const old = messages.slice(0, -20);
    const compressed = await this.compressOldMessages(old);
    
    return [compressed, ...recent];
  }
  
  private async compressOldMessages(messages: Message[]): Promise<Message> {
    // 使用 LLM 总结
    const summary = await this.llm.summarize(messages);
    
    return {
      role: 'system',
      content: `[历史总结] ${summary}`,
      timestamp: messages[0].timestamp
    };
  }
}
```

---

## 上下文窗口管理

### 滑动窗口

```typescript
class SlidingContextWindow {
  private window: Message[];
  private maxSize: number;
  private maxTokens: number;
  
  constructor(maxSize: number = 20, maxTokens: number = 8000) {
    this.window = [];
    this.maxSize = maxSize;
    this.maxTokens = maxTokens;
  }
  
  add(message: Message): void {
    this.window.push(message);
    
    // 按大小限制
    while (this.window.length > this.maxSize) {
      this.window.shift();
    }
    
    // 按 token 限制
    while (this.calculateTokens() > this.maxTokens) {
      this.window.shift();
    }
  }
  
  get(): Message[] {
    return [...this.window];
  }
  
  private calculateTokens(): number {
    return this.window.reduce((sum, msg) => {
      return sum + this.estimateTokens(msg.content);
    }, 0);
  }
  
  private estimateTokens(text: string): number {
    // 简单估算：1 token ≈ 4 字符
    return Math.ceil(text.length / 4);
  }
}
```

---

## 用户偏好管理

### 偏好存储

```typescript
interface UserPreferences {
  // 语言偏好
  language: string;
  
  // 响应风格
  responseStyle: 'concise' | 'detailed' | 'casual';
  
  // 通知设置
  notifications: {
    enabled: boolean;
    channels: string[];
    quietHours: { start: string; end: string };
  };
  
  // 隐私设置
  privacy: {
    saveHistory: boolean;
    shareData: boolean;
  };
  
  // 自定义设置
  custom: Record<string, any>;
}

class PreferencesManager {
  async load(userId: string): Promise<UserPreferences> {
    const stored = await this.storage.get(`preferences:${userId}`);
    return stored || this.getDefaults();
  }
  
  async save(userId: string, preferences: UserPreferences): Promise<void> {
    await this.storage.set(`preferences:${userId}`, preferences);
  }
  
  async update(
    userId: string,
    updates: Partial<UserPreferences>
  ): Promise<void> {
    const current = await this.load(userId);
    const updated = { ...current, ...updates };
    await this.save(userId, updated);
  }
}
```

---

## 会话恢复

### 断点续传

```typescript
class SessionRecovery {
  async recover(sessionId: string): Promise<Session> {
    // 加载会话
    const session = await this.storage.load(sessionId);
    
    if (!session) {
      throw new Error('Session not found');
    }
    
    // 恢复状态
    await this.restoreState(session);
    
    // 验证完整性
    await this.validateSession(session);
    
    return session;
  }
  
  private async restoreState(session: Session): Promise<void> {
    // 恢复 Agent
    if (session.agentState) {
      await this.restoreAgent(session);
    }
    
    // 恢复上下文
    if (session.context) {
      await this.restoreContext(session);
    }
    
    // 恢复任务
    if (session.context.pendingTasks.length > 0) {
      await this.restoreTasks(session);
    }
  }
  
  private async validateSession(session: Session): Promise<void> {
    // 检查数据完整性
    if (!session.id || !session.userId) {
      throw new Error('Invalid session data');
    }
    
    // 检查时间戳
    const age = Date.now() - session.lastActiveAt;
    if (age > 7 * 24 * 60 * 60 * 1000) { // 7 天
      throw new Error('Session expired');
    }
  }
}
```

---

## 会话同步

### 多设备同步

```typescript
class SessionSync {
  async sync(userId: string): Promise<void> {
    // 获取所有设备的会话
    const sessions = await this.getAllSessions(userId);
    
    // 找到最新的会话
    const latest = this.findLatest(sessions);
    
    // 同步到其他设备
    await this.syncToDevices(userId, latest);
  }
  
  private async syncToDevices(
    userId: string,
    session: Session
  ): Promise<void> {
    const devices = await this.getDevices(userId);
    
    for (const device of devices) {
      await this.pushToDevice(device, session);
    }
  }
}
```

---

## 性能优化

### 懒加载

```typescript
class LazySessionLoader {
  async load(sessionId: string): Promise<Session> {
    // 只加载基本信息
    const basic = await this.loadBasic(sessionId);
    
    // 创建代理对象
    return new Proxy(basic, {
      get: (target, prop) => {
        // 按需加载详细信息
        if (prop === 'messages' && !target._messagesLoaded) {
          this.loadMessages(target);
        }
        
        if (prop === 'context' && !target._contextLoaded) {
          this.loadContext(target);
        }
        
        return target[prop];
      }
    });
  }
}
```

### 缓存策略

```typescript
class SessionCache {
  private cache: Map<string, CachedSession>;
  private maxSize: number = 100;
  
  get(sessionId: string): Session | null {
    const cached = this.cache.get(sessionId);
    
    if (!cached) {
      return null;
    }
    
    // 检查是否过期
    if (Date.now() - cached.cachedAt > 5 * 60 * 1000) { // 5 分钟
      this.cache.delete(sessionId);
      return null;
    }
    
    return cached.session;
  }
  
  set(session: Session): void {
    // LRU 淘汰
    if (this.cache.size >= this.maxSize) {
      const oldest = this.findOldest();
      this.cache.delete(oldest);
    }
    
    this.cache.set(session.id, {
      session,
      cachedAt: Date.now()
    });
  }
}
```

---

## 监控和分析

### 会话指标

```typescript
class SessionMetrics {
  async collect(session: Session): Promise<SessionStats> {
    return {
      duration: Date.now() - session.createdAt,
      messageCount: session.messages.length,
      avgResponseTime: this.calculateAvgResponseTime(session),
      taskCompletionRate: this.calculateTaskCompletionRate(session),
      userSatisfaction: await this.estimateSatisfaction(session)
    };
  }
  
  private calculateAvgResponseTime(session: Session): number {
    const responseTimes: number[] = [];
    
    for (let i = 1; i < session.messages.length; i++) {
      if (session.messages[i].role === 'assistant') {
        const userMsg = session.messages[i - 1];
        const assistantMsg = session.messages[i];
        responseTimes.push(assistantMsg.timestamp - userMsg.timestamp);
      }
    }
    
    return responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
  }
}
```

---

## 学习检查点

完成本节后，你应该能够：
- [ ] 理解会话的完整生命周期
- [ ] 掌握持久化策略
- [ ] 了解历史管理和压缩
- [ ] 理解上下文窗口管理
- [ ] 掌握会话恢复机制

---

## 下一步

继续学习：[../03-core-components/README.md](../03-core-components/README.md)
