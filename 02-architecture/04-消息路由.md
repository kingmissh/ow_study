# 消息路由系统

## 概述

消息路由系统负责将来自不同通道的消息正确地路由到对应的 Agent 实例，并管理消息的生命周期。

---

## 核心职责

### 1. 消息解析

将来自不同平台的原始消息转换为统一格式：

```typescript
interface RawMessage {
  channel: string;        // telegram, discord, slack
  channelMessageId: string;
  userId: string;
  content: string;
  timestamp: number;
  metadata: Record<string, any>;
}

interface ParsedMessage {
  id: string;
  userId: string;
  content: string;
  intent: Intent;
  entities: Entity[];
  context: MessageContext;
  timestamp: number;
}
```

### 2. 路由决策

```typescript
class MessageRouter {
  async route(message: ParsedMessage): Promise<Agent> {
    // 1. 查找或创建会话
    const session = await this.sessionManager.getOrCreate(message.userId);
    
    // 2. 选择 Agent
    const agent = await this.selectAgent(message, session);
    
    // 3. 加载上下文
    await agent.loadContext(session);
    
    return agent;
  }
  
  private async selectAgent(
    message: ParsedMessage,
    session: Session
  ): Promise<Agent> {
    // 检查是否有活跃的 Agent
    if (session.activeAgent) {
      return session.activeAgent;
    }
    
    // 根据意图选择 Agent
    const agentType = this.determineAgentType(message.intent);
    
    // 创建新 Agent
    return this.agentFactory.create(agentType, session);
  }
}
```

---

## 消息队列

### 队列管理

```typescript
class MessageQueue {
  private queues: Map<string, Queue<Message>>;
  private processing: Map<string, boolean>;
  
  async enqueue(userId: string, message: Message): Promise<void> {
    const queue = this.getQueue(userId);
    await queue.push(message);
    
    // 触发处理
    this.processQueue(userId);
  }
  
  private async processQueue(userId: string): Promise<void> {
    // 防止并发处理
    if (this.processing.get(userId)) {
      return;
    }
    
    this.processing.set(userId, true);
    
    try {
      const queue = this.getQueue(userId);
      
      while (!queue.isEmpty()) {
        const message = await queue.pop();
        await this.processMessage(message);
      }
    } finally {
      this.processing.set(userId, false);
    }
  }
}
```

### 优先级队列

```typescript
interface PriorityMessage extends Message {
  priority: number; // 0-10, 10 最高
}

class PriorityQueue {
  private heap: PriorityMessage[];
  
  push(message: PriorityMessage): void {
    this.heap.push(message);
    this.bubbleUp(this.heap.length - 1);
  }
  
  pop(): PriorityMessage | undefined {
    if (this.heap.length === 0) return undefined;
    
    const top = this.heap[0];
    const last = this.heap.pop()!;
    
    if (this.heap.length > 0) {
      this.heap[0] = last;
      this.bubbleDown(0);
    }
    
    return top;
  }
}
```

---

## 意图识别

### 意图分类器

```typescript
class IntentClassifier {
  private patterns: Map<Intent, RegExp[]>;
  
  classify(message: string): Intent {
    // 1. 基于规则的分类
    for (const [intent, patterns] of this.patterns) {
      for (const pattern of patterns) {
        if (pattern.test(message)) {
          return intent;
        }
      }
    }
    
    // 2. 基于 LLM 的分类
    return this.classifyWithLLM(message);
  }
  
  private async classifyWithLLM(message: string): Promise<Intent> {
    const prompt = `
      Classify the user's intent:
      Message: "${message}"
      
      Possible intents:
      - query: User is asking a question
      - command: User wants to execute an action
      - conversation: User is having a casual conversation
      - feedback: User is providing feedback
      
      Return only the intent name.
    `;
    
    const response = await this.llm.generate(prompt);
    return response.trim() as Intent;
  }
}
```

### 实体提取

```typescript
class EntityExtractor {
  extract(message: string): Entity[] {
    const entities: Entity[] = [];
    
    // 提取日期
    entities.push(...this.extractDates(message));
    
    // 提取时间
    entities.push(...this.extractTimes(message));
    
    // 提取邮箱
    entities.push(...this.extractEmails(message));
    
    // 提取 URL
    entities.push(...this.extractUrls(message));
    
    // 提取自定义实体
    entities.push(...this.extractCustomEntities(message));
    
    return entities;
  }
  
  private extractDates(message: string): Entity[] {
    const datePatterns = [
      /\d{4}-\d{2}-\d{2}/g,           // 2026-02-18
      /\d{1,2}\/\d{1,2}\/\d{4}/g,     // 02/18/2026
      /(今天|明天|后天|昨天)/g,         // 中文日期
      /(today|tomorrow|yesterday)/gi   // 英文日期
    ];
    
    const entities: Entity[] = [];
    
    for (const pattern of datePatterns) {
      const matches = message.matchAll(pattern);
      for (const match of matches) {
        entities.push({
          type: 'date',
          value: match[0],
          start: match.index!,
          end: match.index! + match[0].length
        });
      }
    }
    
    return entities;
  }
}
```

---

## 上下文构建

### 上下文管理器

```typescript
class ContextBuilder {
  async build(message: ParsedMessage, session: Session): Promise<Context> {
    // 1. 加载会话历史
    const history = await this.loadHistory(session.id);
    
    // 2. 加载相关记忆
    const memories = await this.loadMemories(session.userId, message.content);
    
    // 3. 加载用户配置
    const userConfig = await this.loadUserConfig(session.userId);
    
    // 4. 构建上下文
    return {
      sessionId: session.id,
      userId: session.userId,
      history: this.compressHistory(history),
      memories,
      userConfig,
      currentMessage: message,
      timestamp: Date.now()
    };
  }
  
  private compressHistory(history: Message[]): Message[] {
    // 保留最近的 N 条消息
    const recentCount = 20;
    const recent = history.slice(-recentCount);
    
    // 如果历史太长，总结旧消息
    if (history.length > recentCount) {
      const old = history.slice(0, -recentCount);
      const summary = this.summarizeMessages(old);
      return [summary, ...recent];
    }
    
    return recent;
  }
}
```

---

## 会话管理

### 会话生命周期

```typescript
class SessionManager {
  private sessions: Map<string, Session>;
  private timeouts: Map<string, NodeJS.Timeout>;
  
  async getOrCreate(userId: string): Promise<Session> {
    let session = this.sessions.get(userId);
    
    if (!session) {
      session = await this.createSession(userId);
      this.sessions.set(userId, session);
    }
    
    // 重置超时
    this.resetTimeout(userId);
    
    return session;
  }
  
  private resetTimeout(userId: string): void {
    // 清除旧超时
    const oldTimeout = this.timeouts.get(userId);
    if (oldTimeout) {
      clearTimeout(oldTimeout);
    }
    
    // 设置新超时（30 分钟无活动后关闭会话）
    const timeout = setTimeout(() => {
      this.closeSession(userId);
    }, 30 * 60 * 1000);
    
    this.timeouts.set(userId, timeout);
  }
  
  private async closeSession(userId: string): Promise<void> {
    const session = this.sessions.get(userId);
    if (!session) return;
    
    // 保存会话状态
    await this.saveSession(session);
    
    // 清理资源
    await session.agent?.cleanup();
    
    // 移除会话
    this.sessions.delete(userId);
    this.timeouts.delete(userId);
  }
}
```

---

## 消息过滤

### 垃圾消息过滤

```typescript
class MessageFilter {
  async filter(message: ParsedMessage): Promise<boolean> {
    // 1. 检查消息长度
    if (message.content.length > 10000) {
      return false;
    }
    
    // 2. 检查垃圾内容
    if (this.isSpam(message.content)) {
      return false;
    }
    
    // 3. 检查速率限制
    if (await this.isRateLimited(message.userId)) {
      return false;
    }
    
    return true;
  }
  
  private isSpam(content: string): boolean {
    const spamPatterns = [
      /viagra/i,
      /casino/i,
      /lottery/i,
      // 更多垃圾模式
    ];
    
    return spamPatterns.some(pattern => pattern.test(content));
  }
}
```

---

## 消息转换

### 格式转换器

```typescript
class MessageTransformer {
  // Telegram 消息转换
  fromTelegram(update: TelegramUpdate): RawMessage {
    return {
      channel: 'telegram',
      channelMessageId: update.message.message_id.toString(),
      userId: update.message.from.id.toString(),
      content: update.message.text || '',
      timestamp: update.message.date * 1000,
      metadata: {
        chatId: update.message.chat.id,
        username: update.message.from.username,
        firstName: update.message.from.first_name
      }
    };
  }
  
  // Discord 消息转换
  fromDiscord(message: DiscordMessage): RawMessage {
    return {
      channel: 'discord',
      channelMessageId: message.id,
      userId: message.author.id,
      content: message.content,
      timestamp: message.createdTimestamp,
      metadata: {
        guildId: message.guild?.id,
        channelId: message.channel.id,
        username: message.author.username
      }
    };
  }
  
  // 统一格式转回特定平台
  toTelegram(response: Response): TelegramMessage {
    return {
      chat_id: response.metadata.chatId,
      text: response.content,
      parse_mode: 'Markdown',
      reply_to_message_id: response.metadata.replyToMessageId
    };
  }
}
```

---

## 错误处理

### 路由错误处理

```typescript
class RouterErrorHandler {
  async handle(error: Error, message: ParsedMessage): Promise<void> {
    // 记录错误
    logger.error('Routing error', {
      error: error.message,
      stack: error.stack,
      message: message.id,
      userId: message.userId
    });
    
    // 发送错误响应
    await this.sendErrorResponse(message, error);
    
    // 如果是严重错误，通知管理员
    if (this.isCritical(error)) {
      await this.notifyAdmin(error, message);
    }
  }
  
  private async sendErrorResponse(
    message: ParsedMessage,
    error: Error
  ): Promise<void> {
    const response = this.formatErrorMessage(error);
    await this.gateway.sendMessage(message.userId, response);
  }
  
  private formatErrorMessage(error: Error): string {
    if (error instanceof ValidationError) {
      return '抱歉，您的消息格式不正确。';
    }
    
    if (error instanceof RateLimitError) {
      return '您发送消息太快了，请稍后再试。';
    }
    
    return '抱歉，处理您的消息时出现了错误。';
  }
}
```

---

## 性能优化

### 消息批处理

```typescript
class MessageBatcher {
  private batches: Map<string, Message[]>;
  private timers: Map<string, NodeJS.Timeout>;
  
  add(userId: string, message: Message): void {
    const batch = this.batches.get(userId) || [];
    batch.push(message);
    this.batches.set(userId, batch);
    
    // 设置批处理定时器
    if (!this.timers.has(userId)) {
      const timer = setTimeout(() => {
        this.processBatch(userId);
      }, 100); // 100ms 后处理
      
      this.timers.set(userId, timer);
    }
  }
  
  private async processBatch(userId: string): Promise<void> {
    const batch = this.batches.get(userId);
    if (!batch || batch.length === 0) return;
    
    // 合并相似消息
    const merged = this.mergeMessages(batch);
    
    // 批量处理
    await this.router.routeBatch(merged);
    
    // 清理
    this.batches.delete(userId);
    this.timers.delete(userId);
  }
}
```

---

## 监控指标

### 路由指标

```typescript
class RouterMetrics {
  private metrics = {
    totalMessages: 0,
    routedMessages: 0,
    failedMessages: 0,
    avgRoutingTime: 0,
    queueDepth: new Map<string, number>()
  };
  
  recordRouting(duration: number, success: boolean): void {
    this.metrics.totalMessages++;
    
    if (success) {
      this.metrics.routedMessages++;
    } else {
      this.metrics.failedMessages++;
    }
    
    // 更新平均时间
    this.updateAvgTime(duration);
  }
  
  getMetrics(): RouterMetrics {
    return {
      ...this.metrics,
      successRate: this.metrics.routedMessages / this.metrics.totalMessages,
      failureRate: this.metrics.failedMessages / this.metrics.totalMessages
    };
  }
}
```

---

## 学习检查点

完成本节后，你应该能够：
- [ ] 理解消息路由的完整流程
- [ ] 掌握消息队列的实现
- [ ] 了解意图识别和实体提取
- [ ] 理解上下文构建机制
- [ ] 掌握会话管理策略

---

## 下一步

继续学习：[05-会话管理.md](./05-会话管理.md)
